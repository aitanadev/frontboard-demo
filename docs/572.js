"use strict";(self.webpackChunkfrontboard=self.webpackChunkfrontboard||[]).push([[572],{8572:e=>{e.exports='<template>\n  <div\n    ref="emergentHook"\n    class="c-selector"\n    :class="{\n      \'c-selector--keyboard-navigated\': keyboardNavigated,\n      \'c-selector--multiple\': multiple,\n      \'c-selector--opened\': emergent.opened,\n      \'c-selector--disabled\': disabled\n    }"\n    @select:option.stop\n    @keydown.down.stop.prevent="focusNext(false)"\n    @keydown.up.stop.prevent="focusNext(true)"\n  >\n    <input ref="input" type="hidden" :name="name" :id="id" tid="select_value" :value="inputValue" />\n    <div\n      class="c-selector__handler c-field"\n      @keydown.space.stop="open"\n      @keydown.enter.stop="open"\n      @click="toggle"\n    >\n      <slot v-bind="{Selector: _self}">\n        <div tabindex="0" class="c-selector__handler-input c-input">\n          <div class="c-selector__handler-content">\n            <template v-if="!multiple" class="c-chip">\n              <slot name="value" v-bind="{value: currentValue, option: indexedOptions[currentValue]}">{{ getOptionText(indexedOptions[currentValue]) }}</slot>\n            </template>\n            <template v-else>\n              <span class="c-selector__handler-items  v-scrolled">\n                <span class="c-selector__handler-item c-chip" v-for="valueItem in currentValue">\n                  <span>\n                    <slot name="value" v-bind="{value: valueItem, option: indexedOptions[valueItem]}">{{ getOptionText(indexedOptions[valueItem]) }}</slot>\n                  </span>\n                  <button class="c-selector__clear-item c-action" @click.stop.prevent="selectOption(indexedOptions[valueItem])">\n                    <span class="fi fi-rr-cross-small"></span>\n                  </button>\n                </span>\n              </span>\n            </template>\n          </div>\n        </div>\n        <button v-if="clearable && currentValue" class="c-selector__clear c-action" @click.stop.prevent="clear">\n          <span class="fi fi-rr-cross-small"></span>\n        </button>\n        <button @click.prevent class="c-selector__down c-action"><span class="fi fi-rr-caret-down"></span></button>\n      </slot>\n    </div>\n    <div ref="emergent" class="c-emergent" @click.stop>\n      <div v-if="loading" class="c-emergent__loading"></div>\n      <template v-if="emergent.opened">\n        <div v-if="filterable" class="c-selector__filter">\n          <div class="c-field">\n            <input ref="filter" class="c-input" type="text" :placeholder="filterPlaceholder" v-model="filterText" @input="$emit(\'filter\', $event.target.value)" tid="select_input_filter"/>\n            <button v-if="filterText" class="c-selector__clear c-action" @click.stop.prevent="clearFilterText">\n              <span class="fi fi-rr-cross-small"></span>\n            </button>\n          </div>\n        </div>\n        <SelectorOptions ref="options" :options="options" class="c-selector__options" :grouped="grouped">\n          <template #options.prepend><slot name="options.prepend"></slot></template>\n          <template #option="{option}"><slot name="option" v-bind="{option, selector: _self}"><span v-html="mark(option)"></span></slot></template>\n          <template #options.append><slot name="options.append"></slot></template>\n          <template #options.empty><slot name="options.empty"><strong>{{ emptyMessage }}</strong></slot></template>\n        </SelectorOptions>\n      </template>\n    </div>\n  </div>\n</template>\n\n<script>\n\nimport Emergent from \'services/Emergent\'\nimport SelectorOptions from \'./SelectorOptions\'\n\nexport default {\n  name: \'Selector\',\n\n  components: {\n    SelectorOptions\n  },\n\n  props: {\n    name: { type: String },\n    id: { type: String },\n    options: { type: Array, default: () => [] },\n    value: { type: [String, Object, Array, Boolean, Function, Number] },\n    optionValue: { type: [String, Function], default: \'value\' },\n    optionText: { type: [String, Function], default: \'text\' },\n    useObject: { type: Boolean, default: false },\n    filterable: { type: Boolean, default: false },\n    filter: { type: Function },\n    multiple: { type: Boolean, default: false },\n    multilevel: { type: Boolean, default: false },\n    grouped: { type: Boolean, default: false },\n    keepOpen: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    loading: { type: Boolean, default: false },\n    emptyMessage: { type: String, default: \'No results found.\' },\n    filterPlaceholder: { type: String },\n    clearable: { type: Boolean }\n  },\n\n  data: () => ({\n    currentValue: undefined,\n    emergent: new Emergent(),\n    filterText: \'\',\n    keyboardNavigated: false\n  }),\n\n  created () {\n    this.currentValue = this.parseValue(this.value)\n    document.addEventListener(\'mousemove\', this.skipKeyboardNavigation)\n  },\n\n  watch: {\n    value (value, prevValue) {\n      this.currentValue = this.parseValue(value)\n    },\n    options (value, prevValue) {\n      this.currentValue = this.parseValue(this.value)\n    }\n  },\n\n  mounted () {\n    const self = this\n    this.emergent.sync({\n      element: this.$refs.emergent,\n      hook: this.$refs.emergentHook,\n      config: {\n        spacing: 2,\n        // left: true,\n        inheritWidth: true\n      },\n      onOpen () {\n        self.$emit(\'open\')\n      },\n      onClose () {\n        self.$emit(\'close\')\n      }\n    })\n  },\n\n  beforeDestroy () {\n    document.removeEventListener(\'mousemove\', this.skipKeyboardNavigation)\n    this.emergent.close()\n  },\n\n  computed: {\n    indexedOptions () {\n      return this.optionsWalker(this.options)\n    },\n    inputValue () {\n      if (this.multiple) {\n        return \'[\' + this.currentValue.join(\',\') + \']\'\n      } else {\n        return this.currentValue\n      }\n    }\n  },\n\n  methods: {\n    clear () {\n      this.updateValue()\n    },\n    open () {\n      window.Selector = this\n      if (!this.disabled && !this.emergent.opened) {\n        this.emergent.open()\n        if (this.filterable) {\n          this.$nextTick(() => {\n            this.$refs.filter.focus()\n          })\n        }\n      }\n    },\n    toggle () {\n      if (this.emergent.opened) {\n        this.emergent.close()\n      } else {\n        this.open()\n      }\n    },\n    getOptionValue (option) {\n      if (!option) return option\n      if (typeof option === \'object\') {\n        if (typeof this.optionValue === \'function\') {\n          return this.optionValue(option)\n        } else {\n          return option[this.optionValue]\n        }\n      } else {\n        return option\n      }\n    },\n    getOptionText (option) {\n      if (!option) return \'\'\n      if (typeof option === \'object\') {\n        if (typeof this.optionText === \'function\') {\n          return this.optionText(option)\n        } else {\n          return option[this.optionText]\n        }\n      } else {\n        return option\n      }\n    },\n    isSelected (option) {\n      if (this.multiple) {\n        if (this.multilevel && option.options) {\n          return option.options.every(option => {\n            if (option.options) {\n              return this.isSelected(option)\n            } else {\n              return this.currentValue.some(value => this.getOptionValue(option) === value)\n            }\n          })\n        } else {\n          return this.currentValue.some(value => this.getOptionValue(option) === value)\n        }\n      } else {\n        return this.currentValue === this.getOptionValue(option)\n      }\n    },\n    getSelection (option) {\n      if (this.multiple && this.multilevel && option.options) {\n        let count = 0\n        let total = 0\n        option.options.forEach(option => {\n          if (option.options) {\n            const subSelection = this.getSelection(option)\n            total += subSelection.total\n            count += subSelection.count\n          } else {\n            const selected = this.isSelected(option)\n            total += 1\n            if (selected) count += 1\n          }\n        })\n        return { count, total, complete: count === total }\n      }\n    },\n    selectOption (option) {\n      if (this.multilevel && option.options && !this.multiple) return\n      if (this.multilevel && option.options) {\n        let newOptions = [...this.currentValue]\n        const isSelected = this.isSelected(option)\n        Object.values(this.optionsWalker(option.options)).forEach(option => {\n          if (isSelected) {\n            const optionIndex = this.currentValue.indexOf(this.getOptionValue(option))\n            newOptions.splice(optionIndex, 1)\n          } else {\n            newOptions.push(this.getOptionValue(option))\n          }\n        })\n        this.updateValue(newOptions)\n      } else if (this.multiple) {\n        let newOptions = [...this.currentValue]\n        if (this.isSelected(option)) {\n          const optionIndex = this.currentValue.indexOf(this.getOptionValue(option))\n          newOptions.splice(optionIndex, 1)\n        } else {\n          newOptions.push(this.getOptionValue(option))\n        }\n        this.updateValue(newOptions)\n      } else {\n        this.updateValue(this.getOptionValue(option))\n      }\n      if (!this.keepOpen && !this.multiple) {\n        this.emergent.close()\n      }\n    },\n    parseValue (value) {\n      if (this.multiple && !value) {\n        return []\n      } else if (!this.useObject) {\n        return value\n      } else if (this.multiple) {\n        if (!Array.isArray(value)) throw new Error(\'Selector multiple needs an array as value, passed "\' + typeof value + \'"\')\n        return value.map(value => this.getOptionValue(value))\n      } else {\n        return this.getOptionValue(value)\n      }\n    },\n    updateValue (value) {\n      this.currentValue = value\n      let returnValue\n      if (!this.useObject) {\n        returnValue = value\n      } else if (this.multiple) {\n        returnValue = value.map(value => this.indexedOptions[value])\n      } else {\n        returnValue = this.indexedOptions[value]\n      }\n      this.$emit(\'input\', returnValue)\n      this.$refs.input.dispatchEvent(new Event(\'input\', { bubbles: true }))\n    },\n    optionsWalker (options, result = {}) {\n      options.forEach(option => {\n        if (option.options) {\n          this.optionsWalker(option.options, result)\n        } else {\n          result[this.getOptionValue(option)] = option\n        }\n      })\n      return result\n    },\n    skipKeyboardNavigation () {\n      this.keyboardNavigated = false\n    },\n    focusBack (event) {\n      this.keyboardNavigated = true\n      const parentOption = event.target.closest(\'.c-selector-options\').closest(\'.c-selector-option\')\n      if (parentOption) {\n        const next = parentOption.querySelector(\'.c-selector-option__handler\')\n        if (next) next.focus()\n      }\n    },\n    focusInto (event) {\n      this.keyboardNavigated = true\n      const innerOptions = event.target.closest(\'.c-selector-option\').querySelector(\'.c-selector-options\')\n      if (innerOptions) {\n        const next = innerOptions.querySelector(\'.c-selector-option__handler\')\n        if (next) next.focus()\n      }\n    },\n    focusNext (reverse) {\n      this.keyboardNavigated = true\n      if (!this.emergent.opened) return this.open()\n      const allOptions = [...this.$el.querySelectorAll(\'.c-selector-option__handler\')]\n      const focused = allOptions.includes(document.activeElement) && document.activeElement\n      if (focused) {\n        const closest = focused.closest(\'.c-selector-options\')\n        const siblings = allOptions.filter(option => option.closest(\'.c-selector-options\') === closest)\n        const focusedIndex = siblings.indexOf(focused)\n        const next = (siblings.length + focusedIndex + (reverse ? -1 : 1)) % siblings.length\n        siblings[next].focus()\n      } else {\n        const closest = this.$el.querySelector(\'.c-selector__options\')\n        const siblings = allOptions.filter(option => option.closest(\'.c-selector-options\') === closest)\n        const next = reverse ? siblings[siblings.length - 1] : siblings[0]\n        next.focus()\n      }\n    },\n    mark (option) {\n      return (this.getOptionText(option) || \'\').marker(this.filterText)\n    },\n    clearFilterText () {\n      this.filterText = \'\'\n      this.$refs.filter.focus()\n    }\n  }\n}\n<\/script>\n'}}]);